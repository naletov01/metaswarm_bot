# main.py

import os
import logging
import time
from concurrent.futures import ThreadPoolExecutor

from fastapi import FastAPI, Request, HTTPException
from telegram import Bot, Update, ReplyKeyboardMarkup
from telegram.ext import (
    Dispatcher,
    CommandHandler,
    MessageHandler,
    Filters,
    CallbackContext,
)
from openai import OpenAI
import replicate

import requests, io
from PIL import Image
import json

FUNCTIONS = [
  {
    "name": "generate_image",
    "description": "–°–æ–∑–¥–∞—ë—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–º—É –ø—Ä–æ–º–ø—Ç—É",
    "parameters": {
      "type": "object",
      "properties": {
        "prompt":   {"type":"string", "description":"–¢–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç"},
        "size":     {"type":"string", "enum":["1024x1024","512x512","256x256"]},
        "n":        {"type":"integer", "default":1}
      },
      "required": ["prompt","size"]
    }
  },
  {
    "name": "edit_image",
    "description": "–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç —Ä–∞–Ω–µ–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –ø—Ä–æ–º–ø—Ç—É –∏ –º–∞—Å–∫–µ (RGBA)",
    "parameters": {
      "type": "object",
      "properties": {
        "prompt":      {"type":"string"},
        "size":        {"type":"string", "enum":["1024x1024","512x512","256x256"]},
        "image_file":  {"type":"string","description":"ID —Ñ–∞–π–ª–∞ –≤ Telegram"},
        "mask_file":   {"type":"string","description":"PNG-–º–∞—Å–∫–∞ –≤ –ø–∞–º—è—Ç—å –∫–∞–∫ base64 –∏–ª–∏ ID"}
      },
      "required": ["prompt","size","image_file"]
    }
  }
]

# ‚Äî‚Äî‚Äî –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ‚Äî‚Äî‚Äî
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ‚Äî‚Äî‚Äî –ö–æ–Ω—Ñ–∏–≥ ‚Äî‚Äî‚Äî
BOT_TOKEN           = os.getenv("BOT_TOKEN")
WEBHOOK_SECRET      = os.getenv("WEBHOOK_SECRET")  # –∑–∞–¥–∞–π—Ç–µ –≤ Render –æ—Ç–¥–µ–ª—å–Ω–æ
WEBHOOK_PATH        = f"/webhook/{WEBHOOK_SECRET}"
OPENAI_API_KEY      = os.getenv("OPENAI_API_KEY")
REPLICATE_API_TOKEN = os.getenv("REPLICATE_API_TOKEN")

if not all([BOT_TOKEN, WEBHOOK_SECRET, OPENAI_API_KEY, REPLICATE_API_TOKEN]):
    logger.error("Missing required environment variables")
    raise RuntimeError("Missing API keys or webhook secret")

# ‚Äî‚Äî‚Äî –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ‚Äî‚Äî‚Äî
bot = Bot(token=BOT_TOKEN)
app = FastAPI()
dp = Dispatcher(bot=bot, update_queue=None, use_context=True)

client = OpenAI(api_key=OPENAI_API_KEY)
replicate_client = replicate.Client(token=REPLICATE_API_TOKEN)

executor = ThreadPoolExecutor(max_workers=2)

# ‚Äî‚Äî‚Äî In-memory —Ö—Ä–∞–Ω–∏–ª–∏—â–µ ‚Äî‚Äî‚Äî
user_data   = {}  # user_id ‚Üí {"mode": ..., "last_image": ..., "last_action": timestamp}
user_limits = {}  # user_id ‚Üí {"images": int, "videos": int}

MIN_INTERVAL = 5  # —Å–µ–∫ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏

# ‚Äî‚Äî‚Äî –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ ‚Äî‚Äî‚Äî
def generate_and_send_video(user_id, last_img, prompt):
    data   = user_data.setdefault(user_id, {})
    limits = user_limits.setdefault(user_id, {"images": 0, "videos": 0})
    try:
        output = replicate.run(
            "kwaivgi/kling-v2.1",
            input={
                "mode": "pro",
                "prompt": prompt,
                "duration": 5,
                "start_image": last_img,
                "negative_prompt": "",
            },
        )
        video_url = output.url()
        limits["videos"]    += 1
        data["last_action"]  = time.time()
        bot.send_video(chat_id=user_id, video=video_url)
    except Exception as e:
        logger.error(f"Background video generation failed: {e}")
        bot.send_message(chat_id=user_id, text="–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

# ‚Äî‚Äî‚Äî –•–µ–Ω–¥–ª–µ—Ä—ã ‚Äî‚Äî‚Äî
def error_handler(update, context):
    logger.exception("Unhandled error in update")
dp.add_error_handler(error_handler)

def start(update: Update, context: CallbackContext):
    keyboard = [["üñº –ö–∞—Ä—Ç–∏–Ω–∫–∞", "üéû –í–∏–¥–µ–æ"]]
    markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
    update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:", reply_markup=markup)

def image_upload_handler(update: Update, context: CallbackContext):
    user_id = update.effective_user.id

    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–æ—Ç–æ –∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç-–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    if update.message.photo:
        file_id = update.message.photo[-1].file_id
    elif update.message.document and update.message.document.mime_type.startswith("image/"):
        file_id = update.message.document.file_id
    else:
        update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
        return

    try:
        file = context.bot.get_file(file_id)
        file_url = f"https://api.telegram.org/file/bot{BOT_TOKEN}/{file.file_path}"
        data = user_data.setdefault(user_id, {})
        data["last_image"] = file_url
        data["last_image_id"] = file_id
        data["upload_for_edit"] = True      # <-- —Ñ–ª–∞–≥, —á—Ç–æ —ç—Ç–æ –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è Image-to-Image
        update.message.reply_text(
            "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.\n"
            "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç ‚Äî –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤–º–µ—Å—Ç–µ —Å –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–æ–π."
        )
    except Exception as e:
        logger.error(f"Error saving uploaded image: {e}")
        update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")

def text_handler(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    text    = update.message.text.strip()
    now     = time.time()

    data   = user_data.setdefault(user_id, {})
    limits = user_limits.setdefault(user_id, {"images": 0, "videos": 0})

    # –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
    last = data.get("last_action", 0)
    if now - last < MIN_INTERVAL:
        wait = int(MIN_INTERVAL - (now - last))
        update.message.reply_text(f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –µ—â—ë {wait} —Å–µ–∫.")
        return

    # –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞
    if text in ["üñº –ö–∞—Ä—Ç–∏–Ω–∫–∞", "üéû –í–∏–¥–µ–æ"]:
        data["mode"] = "image" if "–ö–∞—Ä—Ç–∏–Ω–∫–∞" in text else "video"
        update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç:")
        return

    mode = data.get("mode")

    # ‚Äî‚Äî‚Äî –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (T2I –∏–ª–∏ I2I) ‚Äî‚Äî‚Äî
    if data.get("mode") == "image":
        update.message.reply_text("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ GPT-4 Vision‚Ä¶")
    
        # –°–æ–±–∏—Ä–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
        messages = [
            {"role":"system","content":"–¢—ã –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –ø–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π."}
        ]
        if data.get("last_image_id"):
            messages.append({
                "role":"user",
                "content":"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –ø—Ä–æ–º–ø—Ç—É.",
                "image_file": data["last_image_id"]
            })
        else:
            messages.append({"role":"user","content": text})
    
        # –í—ã–∑—ã–≤–∞–µ–º GPT —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏
        resp = client.chat.completions.create(
            model="gpt-4o-mini",   # –∏–ª–∏ gpt-4vision
            messages=messages,
            functions=FUNCTIONS,
            function_call="auto"
        )
    
        msg = resp.choices[0].message

        # —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–∑–≤–∞–Ω–∞?
        fn = getattr(msg, "function_call", None)
        if not fn:
            # –Ω–∏ –æ–¥–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –±—ã–ª–∞ –≤—ã–∑–≤–∞–Ω–∞ ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç
            text = msg.content or "–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ –ø–æ–Ω—è–ª."
            update.message.reply_text(text)
            return
        
        name = fn.name
        args = json.loads(fn.arguments)
    
        if name == "generate_image":
            img = client.images.generate(
                model="dall-e-3",
                prompt=args["prompt"],
                size=args["size"],
                n=args.get("n",1)
            )
            url = img.data[0].url
            update.message.reply_photo(photo=url)
            data["last_image"] = url
    
        elif name == "edit_image":
            tg_file   = bot.get_file(args["image_file"])
            img_bytes = tg_file.download_as_bytearray()
            orig      = io.BytesIO(img_bytes)
    
            pil      = Image.open(orig).convert("RGBA")
            mask     = Image.new("RGBA", pil.size, (0,0,0,0))
            mb       = io.BytesIO(); mask.save(mb,"PNG"); mb.seek(0); orig.seek(0)
    
            out = client.images.edit(
                image  = ("image.png", orig, "image/png"),
                mask   = ("mask.png",  mb,   "image/png"),
                prompt = args["prompt"],
                size   = args["size"],
                n      = args.get("n",1)
            )
            url = out.data[0].url
            update.message.reply_photo(photo=url)
            data["last_image"] = url
    
        data.pop("upload_for_edit", None)
        limits["images"] += 1
        data["last_action"] = time.time()
        return

    # ‚Äî –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ ‚Äî
    if mode == "video":
        last_img = data.get("last_image")
        if not last_img:
            update.message.reply_text("–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
            return
        if limits["videos"] >= 1:
            update.message.reply_text("–õ–∏–º–∏—Ç –≤–∏–¥–µ–æ-–≥–µ–Ω–µ—Ä–∞—Ü–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω.")
            return

        update.message.reply_text("‚è≥ –í–∏–¥–µ–æ –≤ —Ä–∞–±–æ—Ç–µ, –æ—Ç–ø—Ä–∞–≤–ª—é –∫–∞–∫ –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–æ.")
        # –ó–∞–ø—É—Å–∫ –≤ —Ñ–æ–Ω–µ
        executor.submit(generate_and_send_video, user_id, last_img, text)
        return

    update.message.reply_text("–ù–µ–ø–æ–Ω—è—Ç–Ω–æ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –Ω–∞—á–∞–ª–∞.")

# ‚Äî‚Äî‚Äî –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤ ‚Äî‚Äî‚Äî
dp.add_handler(CommandHandler("start", start))
dp.add_handler(
    MessageHandler(
        Filters.photo | (Filters.document & Filters.document.mime_type("image/")),
        image_upload_handler
    )
)
dp.add_handler(MessageHandler(Filters.text & ~Filters.command, text_handler))

# ‚Äî‚Äî‚Äî Webhook endpoint (—Å–µ–∫—Ä–µ—Ç –≤ URL) ‚Äî‚Äî‚Äî
@app.post(WEBHOOK_PATH)
async def telegram_webhook(request: Request):
    try:
        data = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON")
    update = Update.de_json(data, bot)
    dp.process_update(update)
    return {"ok": True}

@app.get("/")
def root():
    return {"status": "Bot is running"}
